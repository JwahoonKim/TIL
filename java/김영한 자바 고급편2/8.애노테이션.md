# 애노테이션

## 애노테이션이 필요한 이유

리플렉션 서블릿은 요청 URL과 메서드 이름이 같다면 해당 메서드를 동적으로 호출 할 수 있다. 하지만 요청 이름과 메서드 이름을 다르게 하고 싶다면 어떻게해야할까? 또한 / , /favicon.ico, /home-new 같은 URL들을 처리할 수가 없는데 어떻게 해야할까?

따라서 추가 정보를 코드 어딘가에 적어두고 읽을 수 있는 수단이 필요하다. 그게 바로 애노테이션이다.

애노테이션은 프로그램 실행 중에도 사용할 수 있는 주석

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface SimpleMapping {
    String value();
}
```

```java
public class TestController {

    @SimpleMapping("/")
    public void home() {
        System.out.println("TestController.home");
    }

    @SimpleMapping("/site1")
    public void page1() {
        System.out.println("TestController.page1");
    }
}
```

애노테이션은 프로그램 코드가 아니다. 위 코드처럼 home(), page1() 같은 코드를 호출해도 프로그램에 아무 영향을 주지 않는다. 주석과 비슷하다고 이해하면 되는데 일반적인 주석은 아니다. 리플렉션 같은 기술로 실행 시점에 읽어서 활용할 수 있는 특별한 주석이다.

아래 코드와 같이 애노테이션 value 값을 꺼내올 수 있다.

```java
public static void main(String[] args) {
    TestController testController = new TestController();
    
    Class<? extends TestController> aClass = testController.getClass();
    
    for (Method method : aClass.getDeclaredMethods()) {
        SimpleMapping simpleMapping = method.getAnnotation(SimpleMapping.class);

        if (simpleMapping != null) {
            System.out.println(simpleMapping.value());
        }
    }
}
```

### 애노테이션 정의

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnoElement {

    // 자바가 기본 제공하는 타입만 제공 가능
    String value();
    int count() default 0;
    String[] tags() default {};
    
}
```

**[데이터 타입]**

- 기본 타입 (int, float, boolean 등)
- String
- Class (메타데이터) 또는 인터페이스
- enum
- 다른 애노테이션 타입
- 위 타입들의 배열

이것 외에는 정의할 수 없다. 즉, 일반적인 클래스를 사용할 수 없다.

**[default 값]**

- 요소에 default 값을 지정할 수 있다.

또한,,

- 반환값을 void 로 할 수 없다.
- 예외를 선언할 수 없다.
- value 라는 이름의 요소를 하나만 가질 경우 애노테이션 사용시 요소 이름 생략 가능

### 메타 애노테이션

애노테이션을 정의하는데 쓰는 특별한 애노테이션

1. Retention
2. Target
3. Documented
4. Inherited

**[Retention]**

애노테이션의 생존 기간을 지정한다.

```java
public enum RetentionPolicy {
    SOURCE, // 소스코드에만 남아있다. 컴파일 시점에 제거. -> 일반 주석이랑 동일
    CLASS, // 컴파일 후 class 파일까지는 남아있지만 런타임에 제거 (기본값)
    RUNTIME // 자바 실행중에도 남아있다. 대부분 이 설정 사용
}
```

**[Target]**

애노테이션을 적용할 수 있는 위치를 지정한다.

```java
ublic enum ElementType {
    // Class, interface (including annotation interface),
    // enum, or record declaration
    TYPE,

    // Field declaration (includes enum constants)
    FIELD,

    // Method declaration
    METHOD,

    // Formal parameter declaration
    PARAMETER,

    // Constructor declaration
    CONSTRUCTOR,

    // Local variable declaration
    LOCAL_VARIABLE,

    // Annotation interface declaration (Formerly known as an annotation type.)
    ANNOTATION_TYPE,

    // Package declaration
    PACKAGE,

    // Type parameter declaration
    TYPE_PARAMETER,
    
		// Use of a type
    TYPE_USE,

    // Module declaration.
    MODULE,
    
    // Record component
    RECORD_COMPONENT;
}
```

**[Documented]**

자바 API 문서를 만들 때 해당 애노테이션이 함계 포함되는지 지정한다. 보통 함께 사용한다.

**[Inherited]**

자식클래스가 애노테이션을 상속 받을 수 있다.

### 애노테이션과 상속

모든 애노테이션은 `java.lang.annotation.Annotation` 인터페이스를 묵시적으로 상속받는다.

```java
package java.lang.annotation;

public interface Annotation {    
    boolean equals(Object obj);
    int hashCode();
    String toString();
    Class<? extends Annotation> annotationType();
}
```

모든 annotation은 Annotation 인터페이스를 확장하며, 이로 인해 자바에서 애노테이션은 특별한 형태의 인터페이스로 간주된다. 자바에서 애노테이션을 정의할때, 개발자가 명시적으로 Annotation 인터페이스를 상속하거나 구현할 필요는 없다. `@interface` 키워드를 통해 정의하면, 자바 컴파일러가 자동으로 Annotation 인터페이스를 확장하도록 처리해준다.

**[애노테이션과 상속]**

- 애노테이션은 다른 애노테이션이나 인터페이스를 직접 상속할 수 없다.
- 오직 Annotation 인터페이스만 상속한다.
- 따라서 애노테이션 사이에는 상속이라는 개념이 존재하지 않는다.

**[@Inherited]**

애노테이션을 정의할 때 `@Inherited` 애노테이션을 붙이면, 애노테이션을 적용한 클래스의 자식도 해당 애노테이션을 부여받을 수 있다.

**주의할 점 : 이 기능은 클래스 상속에서만 작동하고 인터페이스의 구현체에는 적용되지 않는다.**

### Inherited가 클래스 상속에만 적용되는 이유

1. **클래스 상속과 인터페이스 구현의 차이**
    - 클래스 상속은 자식 클래스가 부모 클래스의 속성과 메서드를 상속받는 개념이다. 즉, 자식 클래스는 부모 클래스의 특성을 이어받으므로, 부모클래스에 정의된  애노테이션을 자식 클래스가 자동으로 상속받을 수 있는 논리적 기반이 있다.
    - 인터페이스는 메서드 시그니처만 정의할 뿐, 상태나 행위를 가지지 않기 때문에, 인터페이스의 구현체가 애노테이션을 상속한다는 개념이 잘 맞지 않는다.
2. **인터페이스와 다중 구현, 다이아몬드 문제**
    - 인터페이스는 다중 구현이 가능하다. 만약 인터페이스의 애노테이션을 구현 클래스에서 상속하게되면 여러 인터페이스의 애노테이션 간의 충돌이나 모호한 상황이 발생할 수 있다.

### 자바 기본 애노테이션 몇 가지

- @Override : 자바 컴파일러가 정상적인 오버라이딩인지 확인해준다.
- @Deprecated : 더이상 사용되지 않는다는 뜻이다.
- @SupressWarnings : 자바 컴파일러가 문제를 경고하지만 개발자가 해당 문제를 잘 알고있으니 경고하지 말라고 지시하는 애노테이션이다.