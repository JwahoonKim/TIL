# 리플렉션

## 리플렉션이 필요한 이유

이전 HTTP 서버에서 커맨드 패턴으로 만든 서블릿은 아주 유용했지만 몇가지 단점이 있었다.

- 하나의 클래스에 하나의 기능만 만들 수 있다.
- 새로 만든 클래스를 URL 경로와 항상 매핑해야한다.

### 문제1 : 하나의 클래스에 하나의 기능만 만들 수 있다.

기능 하나 만들때마다 클래스를 만들고 구현해야하는데 이는 복잡한 기능에서는 효과적이지만, 간단한 기능을 만들때는 클래스가 너무 많이 만들어지기때문에 부담스럽다.

아래 코드는 간단함에도 불구하고 각각 클래스로 만들어줘야했다.

```java
public class Site1Servlet implements HttpServlet {
    @Override
    public void service(HttpRequest request, HttpResponse response) {
        response.writeBody("<h1>Site1</h1>");
    }
}

public class Site2Servlet implements HttpServlet {

    @Override
    public void service(HttpRequest request, HttpResponse response) {
        response.writeBody("<h1>Site2</h1>");
    }
}
```

이 문제를 해결할 방법

→ 하나의 클래스에서 다양한 기능을 처리할 수 있게 만들면 된다. → 리플렉션을 이용하면 가능하다.

### 문제2: 새로 만든 클래스에 대한 URL 매핑을 항상 추가해줘야한다.

```java
public static void main(String[] args) throws IOException {
    ServletManager servletManager = new ServletManager();
    servletManager.add("/", new HomeServlet());
    servletManager.add("/search", new SearchServlet());
    servletManager.add("/site1", new Site1Servlet());
    servletManager.add("/site2", new Site2Servlet());
    servletManager.add("/favicon.ico", new DiscardServlet());

    HttpServer server = new HttpServer(PORT, servletManager);
    server.start();
}
```

→ 이 부분도 리플렉션을 이용하면 해결이 가능하다.

## 클래스와 메타데이터

클래스가 제공하는 다양한 정보를 동적으로 분석하고 사용하는 기능을 `리플렉션`이라고 한다. 리플렉션을 통해 프로그램 실행 중에 클래스, 메서드, 필드 등에 대한 정보를 얻거나 새로운 객체를 생성하고 메서드를 호출하며, 필드의 값을 읽고 쓸 수 있다.

**[리플렉션을 통해 얻을 수 있는 정보]**

- **클래스의 메타 데이터** : 클래스 이름, 접근 제어자, 부모 클래스, 구현된 인터페이스 등
- **필드 정보** : 필드의 이름, 타입, 접근 제어자를 확인하고, 해당 필드의 값을 읽거나 수정 가능
- **메서드 정보** : 메서드 이름, 반환 타입, 매개변수 정보등을 확인하고 실행중에 동적으로 메서드 호출 가능
- **생성자 정보** : 생성자의 매개변수 타입과 개수를 확인하고 동적으로 객체 생성 가능

**[클래스의 메타데이터 조회 방법 3가지]**

```java
// 1. 클래스에서 찾기
Class<MyClass> myClass = MyClass.class;

// 2. 인스턴스에서 찾기
MyClass myClass = new MyClass();
// 자식 타입일수도 있기 때문에 ? extends로 타입 지정
Class<? extends MyClass> myClassMetaData = myClass.getClass();

// 3. 문자로 찾기
String className = "package.path.MyClass"; // 패키지명
Class<?> myClass = Class.forName(className);
```

**[리플렉션 이용하여 private 필드 변경하기]**

```java
// id, name, age 모두 private 이라고 가정
User user = new User("id1", "userA", 20);

Class<? extends User> aClass = user.getClass();
Field nameField = aClass.getDeclaredField("name");

// private 필드 접근 허용하도록 변경, 이거 안하면 오류남
// private method도 같은 방식으로 접근 가능함
nameField.sertAccessible(true);

// private 필드여도 바뀜
nameField.set(user, "userB"); 
```

**[리플렉션과 주의사항]**

리플렉션을 활용하면 private 접근 제어자도 직접 접근해서 값을 변경할 수 있다. 하지만 이는 객체지향 프로그래밍 원칙을 위반하는 행위이다. 캡슐화, 유지보수성, 가독성 등에 악영향을 미칠 수 있으며 이는 예상치 못한 버그를 초래할 수 있다. 리플렉션을 사용할때는 반드시 신중하게 사용해야한다.

리플렉션은 테스트나 라이브러리 개발같은 특별한 상황에서는 유용하게 사용할 수도 있다. 일반적인 비즈니스 로직 작성때는 쓰지말자.

### HTTP Sever 6 - 리플렉션 서블릿

- v6 코드 링크

리플렉션을 이용해서 컨트롤러들의 메서드 이름과 path의 이름이 일치하는 경우 해당 메서드를 실행시키도록 하는 방식을 사용한다.

우리가 만든 `ReflectionServlet` 을 default로 쓰는 것이 중요하다.

→ `dispatcherServlet` 같은 역할

**[작동 순서]**

1. 웹 브라우저가 `/site1`에 요청한다.
2. 서블릿 매니저는 등록된 서블릿 중 `/site1` 을 찾는다.
3. 없으니 defaultServlet인 `ReflectionServlet`을 호출한다.
4. ReflectionServlet에서 컨트롤러를 순회하면서 site1()이라는 메서드를 찾아서 호출한다.

**[남은 문제점]**

- 리플렉션 서블릿은 요청 URL과 메서드 이름이 같아야 매칭이된다. → 다르면 매칭이 안되는 문제 있음
- `/`, `/favicon.ico` 같은 자바 메서드 이름으로 처리하기 힘든 URL은 어떻게 처리해야할까?