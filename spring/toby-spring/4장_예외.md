# 4장 예외
예외를 처리하는 베스트 프랙티스를 알아보자.

## 1. 사라진 SQL EXCEPTION

모든 예외는 적절하게 복구하던지 아니면 작업을 중단시키고 개발자에게 분명하게 통보되어야한다.

다음과 같은 코드는 절때 쓰면 안된다.

```java
try {
	...
} catch(Exception e) {} // 무시하고 넘어가기

try {
	...
} catch(Exception e) {
	System.out.println(e); // 콘솔에 찍기
} 
```

예외를 무시하거나 잡아먹어버리는 코드는 작성하면 안된다.

대충 throws Exception 해버리는 것도 나쁜 습관이다.

### 예외의 종류와 특징

**Error**

- 시스템에 비정상 적인 상황이 발생했을 경우
- 주로 JVM에서 발생시키는 것이며 코드에서 해당 예외를 잡으면 안된다.
- 예시) OOM

**Exception과 체크 예외**

- Exception의 서브클래스이면서 RuntimeException의 서브 클래스가 아닌 것들
- 꼭 try-catch 나 throws 문으로 처리해줘야한다.
- 예시) IOException, SQLException

**RuntimeException과 언체크 예외**

- 명시적인 예외처리를 강제하지 않는 예외
- 예시) NPE

그런데.. 초기 자바 언어를 설계한 사람들의 의도와 달리 체크 예외의 불필요성을 주장하는 사람이 늘어났다.

체크 예외로 인해 예외 블랙홀이나 무책임한 throws 문이 남발되기 시작했기 때문이다.

최근 등장하는 자바 표준 스펙 API들은 예외를 언체크 예외로 만드는 경향이 있다.

코틀린에서는 체크예외가 아예 없기도하다.

### 예외처리 방법

- 일반적인 예외 처리 방법을 살펴보고 효과적인 예외 처리 전략을 생각해보자.

**예외복구**

- 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
- 예시

```java
// 1번 예시
1. 사용자가 요청한 파일 읽으려고 시도
2. 파일이 없어서 IOException 발생
3. 사용자에게 알리고 다른 파일 이용하도록 안내 (예외 복구)

// 2번 예시
1. 네트워크 환경이 안좋은 환경에서 DB 접속
2. 네트워크가 원활하지 않아서 DB 접속 실패 (SQLException 발생)
3. 일정시간 대기 후 다시 시도해서 성공 (예외 복구)
```

- 예외 처리 코드를 강제하는 체크 예외는 위 예시와 같이 어떤식으로든 복구할 가능성이 있는 경우 사용해야한다. → 복구할 가능성이 있으니 복구해봐! 라는 메시지를 개발자에게 주는 방식인 것.

**예외처리 회피**

- 예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽에 던져버리는 것 (throws) 혹은 catch 문으로 일단 잡은 후 로그를 남기고 다시 throw 하는 방식
- 콜백과 템플릿처럼 긴밀한 관계로 역할을 분담하는 경우가 아니라면 무책임한 throws가 될 가능성이 있다.
    - 예를 들어 DAO가 던진 SQLException을 Service 계층이 받게된다면 이를 제대로 처리하지 못할 가능성이 많고, 이는 무책임한 예외 처리 회피의 예시이다.
- 예외를 회피하는 것도 예외를 복구하는 것처럼 의도가 분명해야한다. 자신보다 자신을 사용하는 클라이언트가 예외를 다루는게 최선의 방법인 경우 회피 방식을 사용해야한다.

**예외 전환**

- 예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 방식이다.
- 하지만 예외 회피와는 다르게 발생한 예외를 그대로 넘기는게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.
- 예외 전환은 보통 두가지 목적으로 사용된다.
    - 첫 번째는 내부에서 발생한 예외를 그대로 던지는 것이 예외 상황에 대한 적절한 의미를 부여해주지 못하는 경우 그 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서이다. → 예를 들어 같은 아이디의 사용자 등록을 하는 경우 DB에서 `SQLException`이 발생될 것이고 이를 `DuplicateUserIdException` 같은 것으로 변환해서 던져주는 것이다. 이러면 서비스 계층에서 이를 복구할 가능성이 생긴다.

    ```java
    public void add(User user) throws DuplicateUserIdExcetpion, SQLException {
    	try {
    		// user를 추가하는 코드
    	} catch(SQLException e) {
    		if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) {
    			// 예외를 전환할 때 처음 발생한 예외가 무엇인지 담아서(중첩 예외) 만드는 것이 좋다.
    			throw DuplicateUserIdException(e);
    		} else {
    			throw e
    		}
    	}
    }
    ```

    - 두 번째는 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것이다.
    - 중첩 예외를 통해서 기존 예외 정보는 담되 체크 예외를 언체크 예외로 전환해서 던지는 것이 대표적인 예시이다. 어차피 복구 불가능한 예외라면 빠르게 언체크 예외로 돌려서 클라이언트 메소드 시그니처에 불필요한 throws 문을 없애는게 더 좋다. → 어차피 우리는 `ControllerAdvice`, `ExceptionHandler` 같은 기능이 있으니 여기서 처리하도록 하자.


### 예외처리 전략

자바가 처음 만들어질 때 사용되던 AWT, Swing 같은 독립형 애플리케이션 같은 경우 통제 불가능한 시스템 예외더라도 애플리케이션 작업이 중단되지 않게 해주고 상황을 복구해야했다.

하지만 자바 엔터프라이즈 서버환경은 다르다. 수많은 사용자가 동시 요청을 보내고, 각 요청이 독립적인 작업이라고 취급된다. 하나의 요청 처리 중 예외가 발생하면 해당 작업만 중단시키면 그만이다.

→ 독립형 애플리케이션과 다르게 서버 환경에서는 예외가 발생해도 독립형 애플리케이션과 다르게 사용자와 커뮤니케이션하며 예외상황을 복구할 수 있는 방법이 없다.

서버 환경에서는 그냥 빠르게 예외 상황이 발생했음을 개발자에게 통보하는 alert system을 구축하는 편이 더 좋다.

즉, 자바 환경이 서버로 이동하면서 체크 예외의 활용도와 가치가 점점 떨어지고 있다. 예전에는 복구 가능성이 조금이라도 있다면 체크예외를 사용했지만, 지금은 항상 복구할 수 있는 예외가 아니라면 일단 언체크로 만드는 경향이 있다.

### JdbcTemplate에서는 SQLException을 어떻게 처리하는가?

SQLException은 대부분의 경우 개발자가 복구할 방법이 없다. 따라서 SQLException을 런타임 예외인 DataAccessException으로 포장해서 밖으로 던진다. 따라서 JdbcTemplate을 사용하는 DAO에서는 꼭 필요한 예외만 catch해서 잡고 그 외에는 따로 처리하지 않아도 된다.

## 2. 예외 전환

예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 두가지이다.

1. 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws 를 줄여주는 것
2. 로우레벨의 예외를 좀 더 의미있고 추상화된 예외로 바꿔서 던져주는 것

JdbcTemplate에서 던지는 DataAccessException은 1번에 해당한다.

### JDBC의 한계

JDBC는 자표 표준에서도 가장 많이 사용되는 기술 중 하나이다. DB를 이용해 데이터를 저장하고 조회하는 기능은 대부분의 프로그램에서 필요하기 때문이다.

DB별로 서로 다른 API를 제공하고 이 사용법을 각각 익히려면 끔찍하다. JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다.

내부 구현은 DB 마다 다르겠지만 표준 인터페이스를 통해 기능을 제공해주기 때문에 자바 개발자들은 일관된 방법으로 개발을 할 수 있다.

하지만 현실적으로 DB를 자유롭게 바꾸어 사용하기에는 두가지 걸림돌이 있다.

1. **비표준 SQL**
- SQL은 어느정도 표준화 되어있는 언어이지만 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능을 제공한다.
- 이런 비표준 문법을 사용하는 DAO는 곧 특정 DB 기술에 종속적인 코드가 된다.

1. **호환성 없는 SQLException의 DB 에러 정보**
- DB를 사용하다 발생할 수 있는 예외의 원인은 다양하다.
    - SQL 문법오류, DB 커넥션 획득 실패, 유니크 키 중복 등
- 문제는 DB마다 에러의 종류와 원인이 제각각이라는 것이다. → JDBC는 다양한 예외를 그냥 `SQLException` 하나에 모두 담아버린다.
- 예외가 발생한 원인을 확인하려면 SQLException에 담긴 에러 코드를 살펴봐야한다.
    - 근데.. 벤더마다 SQLException에 getErrorCode()를 각자 정의한대로 사용하고 있다.
    - 이 이유로 인해서도 DB 벤더 의존적이지 않은 코드를 만들기도 어려워진다.

### DB 에러코드 매핑을 통한 전환

DB 종류가 바뀌더라도 DAO를 수정하지 않으려면 위에서 언급한 두가지 문제를 해결해야 한다.

비표준 SQL은 책 뒷부분에서 나온다하고 일단 두번째 DB 에러 정보 문제에 대해 알아보자.

DB별로 에러코드를 참고해서 예외 원인이 무엇인지 해석해주는 기능을 중간에 넣어두면 되는데 예를 들어 키값이 중복되는 에러면 MySQL에서는 1062를, 오라클이라면 -1을, DB2라면 -803이라는 에러 코드를 준다.

스프링은 DataAccessException 의 서브클래스로 다양한 예외 클래스들을 정의하고 있다.

- BadSqlGrammarException
- DataAccessResourceFailuerException
- DataIntegrityViolationException
- 등등

이렇게 정의해두고 DB마다 다른 에러코드를 매핑정보를 스프링이 만들어서 제공한다.

JdbcTemplate은 단순히 SQLException을 런타임 예외인 DataAccessException으로 포장하는 것이 아니라 DB 에러코드를 매핑정보에 맞춰 DataAccessException 클래스 중 하나로 매핑해준다.

→ 스프링은 이런 방식을 통해 벤더 의존적이지 않게 DB 관련 예외처리를 다룰 수 있게 해준다.

### DAO 인터페이스와 DataAccessException 계층 구조

DataAccessException은 JDBC의 SQLException을 전환하는 용도로만 사용하는 것이 아니다. 스프링에서는 DB 접근 기술이 다양한데 이들에서 발생하는 예외도 전환해준다.

이 과정에서 의미가 같은 예외가 발생한다면 DB 접근 기술과 관계없이 일관된 예외가 발생할 수 있도록 해준다. → DB 접근 기술에 독립된 추상화된 예외를 제공하는 것

즉, 다양한 DB 접근 기술을 사용할 때 발생하는 예외를 추상화해서 DataAccessException 계층 구조 안에 정리해둠 → DB 접근 기술에서 발생하는 대부분의 예외를 DataAccessException 의 서브클래스 중 하나로 전환해서 던져준다.

이를 통해 DAO를 DB 접근 기술과 독립시킬 수 있다.

- 인터페이스 도입
- 런타임 예외 전환
- 기술에 독립적인 추상화된 예외로 전환