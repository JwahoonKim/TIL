
# CHAPTER.03

## 코드에서 나는 악취

리팩터링을 언제하고 언제 그만둘지를 아는것은 매우 중요하다. 다만 리팩토링 종료 시점을 아는 것은 경험의 영역이다. 따라서 리팩터링해야겠다고 인지할 수 있게끔 코드의 나쁜 냄새를 맡을 수 있게끔 기준을 제시해본다. 물론 이 부분도 경험으로 터득하는 것이 가장 좋다.

### 기이한 이름

코드는 단순하고 명료한 것이 좋다. 코드를 가장 명료하게 표현하는데 가장 중요한 요소는 바로 `이름`이다.

함수, 모듈, 변수, 클래스 등은 이름만 보고도 각각이 무엇을 하고 어떻게 사용해야하는지 명확히 알 수 있도록 엄청나게 신경써서 이름을 지어야한다.

프로그래밍에서 이름짓기는 매우 어려운 일에 속한다. 하지만 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 가능성이 높다. 그래서 혼란스러운 이름들을 리팩터링하다보면 코드가 더 간결해질 때가 많다.

### 중복 코드

똑같은 코드가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 구조를 만들 수 있는지 살펴봐야한다.

코드가 중복되면 각각을 볼 때 서로 차이점은 없는지 살펴봐야하는 부담이 생기고, 변경이 생길때 여러군데에 수정을 해줘야한다.

### 긴 함수

오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성된다.

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 이름을 잘지어두면 본문 코드를 볼 이유가 사라진다. 따라서 코드를 왔다갔다해야하는 비용도 줄어든다. 함수 이름은 동작방식이 아닌 의도가 드러나게 지어야한다.

심지어 원래 코드보다 길어지더라도 의도와 목적이 잘 드러나면 함수로 쪼갠다.

함수를 짧게 만드는 작업의 99%는 `함수 추출하기`이다.

함수가 매개변수와 임시 변수를 많이 사용하면 추출 작업에 방해가 된다. 이에 대한 해결책도 뒤에서 알아볼 것이다.

### 긴 매개변수 목록

매개변수 목록이 길어지면 그 자체로 이해하기가 어려워질 수 있다.

### 전역 데이터

전역데이터는 코드베이스 어디에서든 건드릴수 있고, 그 값을 누가 바꿨는지 찾아낼 메커니즘이 없다. → 버그 가능성이 올라가고, 버그를 찾아내기도 어렵다. 이와 비슷한 형태로 클래스 변수와 싱글톤이있다.

이를 방지하기 위해서 우리는 대표적으로 `변수 캡슐화하기`를 사용할 수 있다.

### 가변 데이터

데이터를 변경했더니 버그가 생기는 경우가 있다. 이러한 버그는 원인을 파악하기 매우 어렵다.

### 뒤엉킨 변경

우리는 소프트웨어를 변경하기 쉬운 형태로 조직해야한다. 코드를 수정할 때 고쳐야할 딱 한군데를 찾아서 그 부분만 수정할 수 있기를 바란다. 이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술(뒤에 나옴) 중 하나의 악취가 풍기는 것이다.

뒤엉킨 변경은 SRP가 제대로 지켜지지 않을때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을때 발생한다.

예를 들어 금융상품을 하나 추가할 때마다 함수 세 개를 바꿔야하고, 지원해야하는 DB가 추가될때 다른 함수 네 개를 바꿔야하는 하나의 모듈이 있다면 뒤엉킨 변경이 발생한 것이다. DB 연동과 금융상품 추가는 서로 다른 맥락이므로 독립된 모듈로 분리해야 프로그래밍이 편하다.

개발 초기에는 맥락 사이의 경계를 명확히 나누기가 어렵고 소프트웨어 시스템의 기능이 변경되면서 이 경계또 계속 움직이기 때문에 계속하여 리팩터링해야한다.

### 산탄총 수술

산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대이다.

코드를 변경할때마다 자잘하게 수정해야하는 클래스가 많을 때 풍기는 코드스멜이다. 변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야할 곳을 지나치기 쉽다. 이럴 때는 함께 변경되는 대상을 한 모듈에 옮겨놓는 것이 좋다.

이렇게 하면 모듈 하나가 커질수는 있고, 우리는 작은 함수와 클래스에 집착하지만 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐져도 괜찮다.

### 기능 편애

한 모듈의 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용하는 일이 많다면 코드 스멜이 나는것이다. 예를 들어 외부 객체의 게터, 세터 메서드를 대여섯개씩 호출하도록 작성된 함수

함께 변경될 대상은 한데 모아야한다.

### 데이터 뭉치

A, B, C 데이터가 항상 메서드 파라미터들에 같이 나타나는 것처럼 데이터가 같이 어울려 다닌다면 이를 합쳐야하는 신호이다.

데이터 뭉치인지 확인하려면 값 하나를 삭제해보면 된다. 이 때 나머지 값들이 의미가 없어진다면 하나의 클래스로 합쳐야하는 신호이다.

클래스로 합치다보면 이 클래스에서 할 수 있는 동작들이 생기는 경우가 많다. 이렇게되면 상당한 중복을 없애고 개발을 가속화 할 수 있는 유용한 클래스로 탄생하기도 한다.

### 기본형 집착

이메일, 전화번호, 단위가 있는 숫자 등은 기본형 혹은 String 타입으로 두지 않는 것이 좋다.

객체로 바꿈으로써 의미있는 행위를 추가할 수 있게 된다.

### 반복되는 switch 문

길고 중복된 switch문은 다형성을 이용해 해결할 수 있는 문제 중 하나이다.

### 반복문

반복문은 filter, map 같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지 좀 더 쉽게 알 수 있다.

→ 이건 맞는말인지 잘모르겠다..

### 성의없는 요소

하나의 메서드만 가지는 클래스나 본문 코드를 그대로 쓰는 것이나 다름없는 메서드는 없는것이 더 좋을 수도 있다.

### 추측성 일반화

`나중에 필요할거야` 라고 생각하며 코드를 더 복잡하게 쓰고, 이해하기 어렵게 만든다면 문제가 있다.

당장 하는 일이 거의 없는 추상클래스는 없애고, 쓸데없는 메서드는 인라인시켜버리자.

### 임시 필드

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올때는 보통 모든 필드가 채워져있을 것이라 기대한다. 이 역시 코드 스멜이며, 해결법은 뒤에서 알아본다.

### 메시지 체인

```java
var managerName = aPerson.department.manager.name;
```

위 코드와 같이 게터가 꼬리에 꼬리를 물고 이어지는 구조도 코드 스멜이다. 이는 클라이언트가 객체 네비게이션 구조에 종속됐음을 의미한다.

### 중개자

보통 클래스가 맡은일을 전부 하지 못할 때 다른 클래스로 위임을 한다.

근데 클래스의 메서드 대부분이 위임로직이라면 이 클래스를 제거하는 것도 고려해봐야한다.

### 거대한 클래스

한 클래스가 너무 많은 일을 하려다보면 필드 수가 상당히 늘어난다. 그리고 필드가 늘어나면 중복 코드가 생기기 쉽다. 클라이언트가 거대 클래스를 어떻게 사용하는지 패턴을 파악하면 어떻게 분리할 수 있을지 가늠이 잡힐 수 도 있다. 거대 클래스의 특정 기능 그룹만 주로 사용한다면 개별 클래스로 추출될 후보이다.